\documentclass{irmaart}
\input{ha.sty}
%========== gastex =====================================
\usepackage{gastex}
%========== vaucanson =====================================
\usepackage{vaucanson-g}
\ChgStateLineWidth{0.5}
\ChgEdgeLineWidth{0.5}

\newcommand{\SqrState}[3][]%
 {\StateStyle %
  \psset{framearc=0}%
  \settowidth{\VariableStateWidth}{\scalebox{\StateLabelSca}{\scalebox{\StateLabelScale}{$#1$}}}%
  \addtolength{\VariableStateWidth}{\ExtraSpace}
  \ifthenelse{\lengthtest{\VariableStateWidth < \VariableStateIntDiam}}%
        {\setlength{\VariableStateWidth}{\VariableStateIntDiam}}{}%
  \setlength{\VariableStateITPos}{\ArrowOnStateCoef\StateDiam}%
  \addtolength{\VariableStateITPos}{0.5\VariableStateWidth}%
  \addtolength{\VariableStateITPos}{-0.5\StateDiam}%
  \rput#2{\pnode(\VariableStateITPos,0){#3e}%
          \pnode(-\VariableStateITPos,0){#3w}%
          \pnode(0,\ArrowOnStateCoef\StateDiam){#3n}%
          \pnode(0,-\ArrowOnStateCoef\StateDiam){#3s}}%
  \rput#2{\rnode{#3}{\psframebox{\protect\rule[-.5\VariableStateIntDiam]{0pt}{\VariableStateIntDiam}\protect\rule{\VariableStateWidth}{0pt}}}}
  \rput#2{\VaucStateRBLabel{#1}}%
}%
%========== Shows labels refs linenumbers ==============
\usepackage[displaymath]{lineno}
\usepackage[notcite]{showkeys}
     \linenumbers
%========== Hyperref at the end ========================
\usepackage[hypertex,hyperindex,pagebackref,final]{hyperref}
%========== Time calculation ==============================
\usepackage{calc}
\newcounter{hours}\newcounter{minutes}
\newcommand\printtime{\setcounter{hours}{\time/60}%
  \setcounter{minutes}{\time-\value{hours}*60}%
  \thehours\,h\,\theminutes}
\newcommand\dateandtime{\today\quad\printtime}
%========== Algorithms ====================================
\usepackage[boxed]{algorithm}    % pour les floats algorithmes
\usepackage[noend]{algorithmic}  % pour les algorithmes
  \newlength\commentspace
  \setlength{\commentspace}{3cm}
  \newcommand\algcomment[2]{\makebox[0pt][l]{\hspace{-#1em}%
    \hspace{\commentspace}$\triangleright$ #2}}
\newcommand{\algorithmicfunc}[1]{\textsc{#1}}
\newcommand{\FUNC}[1]{\item[\algorithmicfunc{#1}]}
%========== PSTricks =====================================
\usepackage{pst-all}
 \newpsobject{showgrid}{psgrid}{%
  subgriddiv=1,griddots=10,gridlabels=6pt}
%========== Proofs =====================================
%------------- end of proof in equation -------
\newcommand{\eqed}{\tag*{\qedsymbol}}
%========== Math notations ===================================
\newcommand{\Card}{\operatorname{Card}}
\newcommand\A{\mathcal{A}}
\newcommand\B{\mathcal{B}}
\newcommand\Tau{T}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{\mathcal{T}}
\newcommand{\cU}{\mathcal{U}}
\newcommand{\cW}{\mathcal{W}}
\newcommand\e{\varepsilon}

%========== Shortcuts =============================
\newcommand{\sa}{synchronizing au\-tom\-a\-ta}
\newcommand{\san}{synchronizing au\-tom\-a\-ton}
\newcommand{\sw}{reset word}
\newcommand{\sws}{reset words}
%========== Hyphenation =============================

%====================================================
\begin{document}
%========== Headers =============================
\markboth{J.~Kari, M.~Volkov}{\v{C}ern\'{y}'s Conjecture and the
Road Coloring Problem}

%=====================================================
\title{\v{C}ern\'{y}'s conjecture and the road coloring problem}
\author{Jarkko Kari$^1$,
  Mikhail Volkov$^2$}
\address{$^1$Department of Mathematics\\
FI-20014 University of Turku\\
Turku, Finland\\[2mm]
$^2$Department of Mathematics and Mechanics\\
620083 Ural State University\\
Ekaterinburg, Russia\\
email:\,\url{jkari@utu.fi,Mikhail.Volkov@usu.ru}\\[4mm]
\upshape{\dateandtime}}

%=====================================================
\maketitle\label{chapterKV}
%=====================================================

\begin{classification}
  68Q45
\end{classification}

\begin{keywords}
  Finite automata, Synchronizing automata, Reset words, \v{C}ern\'{y}'s conjecture,
  Road Coloring Problem
\end{keywords}



%==================================================
%Abstract
%\input{0-Abstract}
%Table of contents
\localtableofcontents

%=====================================================
\section{Synchronizing automata, their origins and importance}
%=====================================================
A complete deterministic finite automaton (DFA) $\mathcal{A}$
with input alphabet $A$ and state set $Q$ is called
\emph{synchronizing}\index{automaton!synchronizing} if there
exists a word $w\in A^*$ whose action resets $\mathcal{A}$, that
is, $w$ leaves the automaton in one particular state no matter
at which state in $Q$ it is applied: $q\cdot w=q'\cdot w$ for all
$q,q'\in Q$. Any word $w$ with this property is said to be a
\emph{reset}\index{reset word} word for the automaton.

\begin{figure}[ht]
\begin{center}
\begin{picture}(50,45)(-15,-10)
\node(A)(0,20){0} \node(B)(20,20){1} \node(C)(20,0){2}
\node(D)(0,0){3} \drawedge(A,B){$a,b$} \drawedge(B,C){$b$}
\drawedge(C,D){$b$} \drawedge(D,A){$b$}
\drawloop[loopangle=45](B){$a$} \drawloop[loopangle=-45](C){$a$}
\drawloop[loopangle=-135](D){$a$}
\end{picture}
\caption{A synchronizing automaton}\label{KV:fig:C4}
\end{center}
\end{figure}
Figure~\ref{KV:fig:C4} shows an example of a \san\ with 4~states.
The reader can easily verify that the word $ab^3ab^3a$ resets the
automaton leaving it in the state 1. With somewhat more effort one
can also check that $ab^3ab^3a$ is the shortest reset word for
this automaton. The example in Figure~\ref{KV:fig:C4} is due to
\v{C}ern\'{y}, a Slovak computer scientist, in whose pioneering
paper~\cite{Cerny:1964} the notion of a \san\ explicitly appeared
for the first time. (\v{C}ern\'{y} called such automata
\emph{directable}.  The word \emph{synchronizing} in this context
was probably introduced by Hennie~\cite{Hennie:1964}.
\marginpar{\textbf{Needs double-checking!!}}) Implicitly, however,
this concept has been around since the earliest days of automata
theory.  The very first \san\ that we were able to trace back in
the literature appeared in Ashby's classic book~\cite[pp.\,60--61]{Ashby:1956}.

In~\cite{Cerny:1964} the notion of a \san\ arose within the
classic framework of Moore's
``Gedanken-experiments''~\cite{Moore:1956}. For Moore and his
followers finite automata served as a mathematical model of
devices working in discrete mode, such as computers or relay
control systems. This leads to the following natural problem: how
can we restore control over such a device if we do not know its
current state but can observe outputs produced by the device under
various actions? Moore~\cite{Moore:1956} has shown that under
certain conditions one can uniquely determine the state at which
the automaton arrives after a suitable sequence of actions (called
an \emph{experiment}). Moore's experiments were adaptive, that is,
each next action was selected on the basis of the outputs caused
by the previous actions. Ginsburg~\cite{Ginsburg:1958} considered
more restricted experiments that he called \emph{uniform}. A
uniform experiment\footnote{After \cite{Gill:1961}, the name
\emph{homing sequence} has become standard for the notion.} is
just a fixed sequence of actions, that is, a word over the input
alphabet; thus, in Ginsburg's experiments outputs were only used
for calculating the resulting state at the end of an experiment.
From this, just one further step was needed to come to the setting
in which outputs were not used at all. It should be noted that
this setting is by no means artificial---there exist many
practical situations when it is technically impossible to observe
output signals. (Think of a satellite which loops around the Moon
and cannot be controlled from the Earth while ``behind'' the
Moon.)

The original ``Gedanken-experiments'' motivation for studying \sa\
is still of importance, and reset words are frequently applied in
model-based testing of reactive systems. See \cite{Cho&Jeong&Somenzi&Pixley:1993,
Boppana&Rajan&Takayama&Fujita:1999} as typical samples of technical
contributions to the area and \cite{Sandberg:2005} for a recent survey.

Another stong motivation comes from the coding theory. We refer to
\cite[Chapters~3 and~10]{Berstel&Perrin&Reutenauer:2009} for a detailed
account of profound connections between codes and automata; here we
restrict ourselves to a brief introduction into a special (but still
very important) case of maximal prefix codes. Recall that a \emph{prefix
code}\index{prefix code} over a finite alphabet $A$ is a set $X$ of words
in $A^*$ such that no word of $X$ is a prefix of another word of $X$.
A prefix code is \emph{maximal}\index{prefix code!maximal} if it is
not contained in another prefix code over the same alphabet. A maximal
prefix code $X$ over $A$ is \emph{synchronized}\index{prefix code!synchronized}
if there is a word $x\in X^*$ such that for any word $w\in A^*$, one has $wx\in X^*$.
Such a word $x$ is called a \emph{synchronizing word}\index{synchronizing word
of a code} for $X$. The advantage of synchronized codes is that they are able
to recover after a loss of synchronization between the decoder and the coder
caused by channel errors: in the case of such a loss, it suffices to transmit
a synchronizing word and the following symbols will be decoded correctly. Moreover,
since the probability that a word $v\in A^*$ contains a fixed word $x$ as a factor
tends to 1 when the length of $v$ increases, synchronized codes eventually
resynchronize by themselves, after sufficiently many symbols being sent.
(As shown in~\cite{Capocelli&Gargano&Vaccaro:1988}, the latter property in fact
characterizes synchronized codes.) The following simple example illustrates
these ideas: let $A=\{0,1\}$ and $X=\{000,0010,0011,010,0110,0111,10,110,111\}$.
Then $X$ is a maximal prefix code and one can easily check that each of the words
010, 011110, 011111110, \dots\ is a synchronizing word for $X$. For instance,
if the code word 000 has been sent but, due to a channel error, the word 100
has been received, the decoder interprets 10 as a code word, and thus, loses
synchronization. However, with a high probability this synchronization loss
only propagates for a short while; in particular, the decoder definitely
resynchronizes as soon as it encounters one of the segments 010, 011110, 011111110, \dots\
in the received stream of symbols. A few samples of such streams are shown
in Figure~\ref{KV:fig:decoding} in which vertical lines show the partition
of each stream into code words and the boldfaced code words indicate
the position at which the decoder resynchronizes.
\begin{figure}[h]
\begin{center}
\begin{tabular}{ll}
Sent & $0\,0\,0\ \mid 0\,0\,1\,0\,\ \mid\mathbf{0\,1\,1\,1\mid\dots}$\\
\mathstrut Received & $1\,0\mid 0\,0\,0 \mid 1\,0 \mid\mathbf{0\,1\,1\,1\mid\dots}$\\
\hline
\mathstrut Sent & $0\,0\,0\mid 0\,1\,1\,1 \mid 1\,1\,0\mid 0\,0\,1\,1 \mid 0\,0\,0 \mid 1\,0 \mid\mathbf{1\,1\,0\mid \dots}$\\
\mathstrut Received & $1\,0\mid 0\,0\,1\,1 \mid 1\,1\,1 \mid 0\,0\,0\mid 1\,1\,0 \mid 0\,0\,1\,0 \mid\mathbf{1\,1\,0\mid \dots}$\\
\hline
\mathstrut Sent & $0\,0\,0\mid 0\,0\,0 \mid 1\,1\,1\mid\mathbf{1\,0\mid \dots}$\\
\mathstrut Received & $1\,0\mid 0\,0\,0 \mid 0\,1\,1\,1 \mid\mathbf{1\,0\mid \dots}$
\end{tabular}
\caption{Restoring synchronization}\label{KV:fig:decoding}
\end{center}
\end{figure}

If $X$ is a finite prefix code over a finite alphabet $A$, then its decoding
can be implemented by a deterministic automaton that is defined as follows.
Let $Q$ be the set of all proper prefixes of the words in $X$ (including the empty word
$\varepsilon$). For $q\in Q$ and $a\in A$, define
$$q\cdot a =\begin{cases} qa & \text{if $qa$ is a proper prefix of a word of $X$},\\
\varepsilon & \text{if $qa \in X$}.\end{cases}$$
The resulting automaton $\mathcal{A}_X$ is complete whenever the code $X$
is maximal and it is easy to see that $\mathcal{A}_X$ is a \san\ if and only
if $X$ is a synchronized code. Moreover, a word $x$ is synchronizing for $X$
if and only if $x$ is a \sw\ for $\mathcal{A}_X$ and sends all states in $Q$
to the state $\varepsilon$. Figure~\ref{KV:fig:huffman} illustrates this construction
for the code $X=\{000,0010,0011,010,0110,0111,10,110,111\}$ considered above.
The solid/dashed lines correspond to (the action of) 0/1.
\begin{figure}[htbp]
\FixVCScale{0.4}
\VCDraw{%
\begin{VCPicture}{(0,-1)(16,9)}
\MediumState
\ChgEdgeArrowWidth{6.5pt}
\VCPut{(0,0)}{
 \RstStateFillColor
\SqrState[0010]{(2,0)}{14}%
\SqrState[0011]{(4,0)}{15}%
\SqrState[0110]{(6,0)}{16}%
\SqrState[0111]{(8,0)}{17}%
\State[4]{(3,2)}{4}%
\SqrState[000]{(1,2)}{9}%
\State[7]{(7,2)}{7}%
\SqrState[010]{(5,2)}{10}%
\SqrState[110]{(11,2)}{11}%
\SqrState[111]{(13,2)}{12}%
\State[3]{(2,4)}{3}%
\State[6]{(6,4)}{6}%
\State[8]{(12,4)}{8}%
\SqrState[10]{(10,4)}{13}%
\State[2]{(4,6)}{2}%
\State[5]{(11,6)}{5}%
\State[1]{(8,8)}{1}%
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{solid}
\EdgeL[.5]{1}{2}{}
\EdgeL[.5]{2}{3}{}
\EdgeL[.5]{5}{13}{}
\EdgeL[.5]{3}{9}{}
\EdgeL[.5]{6}{10}{}
\EdgeL[.5]{8}{11}{}
\EdgeL[.5]{4}{14}{}
\EdgeL[.5]{7}{16}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{dashed}
\EdgeL[.5]{1}{5}{}
\EdgeL[.5]{2}{6}{}
\EdgeL[.5]{8}{12}{}
\EdgeL[.5]{4}{15}{}
\EdgeL[.5]{7}{17}{}
\EdgeL[.5]{5}{8}{}
\EdgeL[.5]{3}{4}{}
\EdgeL[.5]{6}{7}{}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\VCPut{(16,-2)}{
 \RstStateFillColor
\State[4]{(3,2)}{4}%
\State[7]{(7,2)}{7}%
\State[3]{(2,4)}{3}%
\State[6]{(6,4)}{6}%
\State[8]{(12,4)}{8}%
\State[2]{(4,6)}{2}%
\State[5]{(11,6)}{5}%
\State[1]{(8,8)}{1}%
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{solid}
\EdgeL[.5]{1}{2}{}
\EdgeL[.5]{2}{3}{}
\VCurveR[0.5]{angleA=90,angleB=2,ncurv=1.2}{5}{1}{}
\VArcR[.5]{arcangle=60,ncurv=0.7}{3}{1}{}
\ArcR[.5]{6}{1}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{dashed}
\EdgeL[.5]{1}{5}{}
\EdgeL[.5]{2}{6}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{solid}
\VCurveR[0.5]{angleA=140,angleB=140,ncurv=1.6}{4}{1}{}
\VCurveR[0.5]{angleA=20,angleB=50,ncurv=.9}{8}{1}{}
\VCurveR[0.5]{angleA=25,angleB=-74,ncurv=.6}{7}{1}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{dashed}
\EdgeL[.5]{3}{4}{}
\EdgeL[.5]{6}{7}{}
\EdgeL[.5]{5}{8}{}
\VCurveR[0.5]{angleA=170,angleB=120,ncurv=1.9}{4}{1}{}
\VCurveR[0.5]{angleA=10,angleB=76,ncurv=1.2}{8}{1}{}
\VCurveR[0.5]{angleA=15,angleB=-56,ncurv=.8}{7}{1}{}
}
\end{VCPicture}%
}
\caption{A synchronized code (on the left) and its automaton (on the right)}\label{KV:fig:huffman}
\end{figure}


An additional source of problems related to \sa\ has come from
\emph{robotics} or, more precisely, from part handling problems
in industrial automation such as part feeding, fixturing, loading,
assembly and packing. Within this framework, the concept of a \san\
was again rediscovered in the mid-1980s by Natarajan \cite{Natarajan:1986,
Natarajan:1989} who showed how \sa\ can be used to design sensor-free
orienters for polygonal parts, see \cite[Section~1]{Volkov:2008} for
a transparent example illustrating Natarajan's approach in a nutshell.
Since the 1990s \sa\ usage in the area of robotic manipulation has grown
into a prolific research direction but it is fair to say that publications
in this area deal mostly with implementation technicalities. However,
amongst them there are papers of significant theoretical importance
such as \cite{Eppstein:1990,Goldberg:1993,Chen&Ierardi:1995}.

\section{Algorithmic and complexity issues}

\section{The \v{C}ern\'{y} conjecture}

\section{The Road Coloring Problem}

\section{Generalizations}

\bibliographystyle{abbrv}
\addcontentsline{toc}{section}{References}
\begin{footnotesize}
  \bibliography{abbrevs,SA}
\end{footnotesize}


\addcontentsline{toc}{section}{Index}
\markright{\indexname}\markboth{\indexname}{\indexname}
\printindex

\end{document}

\begin{figure}[htbp]
%\SmallPicture
\FixVCScale{0.4}
\VCDraw{%
\begin{VCPicture}{(0,-1)(16,12)}
% etats
\MediumState
\ChgEdgeArrowWidth{6.5pt}
\VCPut{(0,0)}{
 \RstStateFillColor
\SqrState[a]{(2,0)}{14}%
\SqrState[b]{(4,0)}{15}%
\SqrState[d]{(6,0)}{16}%
\SqrState[e]{(8,0)}{17}%
\State[4]{(3,2)}{4}%
\SqrState[c]{(1,2)}{9}%
\State[7]{(7,2)}{7}%
\SqrState[f]{(5,2)}{10}%
\SqrState[g]{(11,2)}{11}%
\SqrState[h]{(13,2)}{12}%
\State[3]{(2,4)}{3}%
\State[6]{(6,4)}{6}%
\State[8]{(12,4)}{8}%
\SqrState[i]{(10,4)}{13}%
\State[2]{(4,6)}{2}%
\State[5]{(11,6)}{5}%
\State[1]{(8,8)}{1}%
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{solid}
\EdgeL[.5]{1}{2}{}
\EdgeL[.5]{2}{3}{}
\EdgeL[.5]{5}{13}{}
\EdgeL[.5]{3}{9}{}
\EdgeL[.5]{6}{10}{}
\EdgeL[.5]{8}{11}{}
\EdgeL[.5]{4}{14}{}
\EdgeL[.5]{7}{16}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
%\ChgEdgeLineStyle{solid}
\ChgEdgeLineStyle{dashed}
\EdgeL[.5]{1}{5}{}
\EdgeL[.5]{2}{6}{}
\EdgeL[.5]{8}{12}{}
\EdgeL[.5]{4}{15}{}
\EdgeL[.5]{7}{17}{}
\EdgeL[.5]{5}{8}{}
\EdgeL[.5]{3}{4}{}
\EdgeL[.5]{6}{7}{}
}
%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%
\VCPut{(16,-2)}{
 \RstStateFillColor
%\SqrState[a]{(0,0)}{14}%
%\SqrState[b]{(2,0)}{15}%
%\SqrState[d]{(4,0)}{16}%
%\SqrState[e]{(6,0)}{17}%
\State[4]{(1,2)}{4}%
%\SqrState[c]{(3,2)}{9}%
\State[7]{(5,2)}{7}%
%\SqrState[f]{(7,2)}{10}%
%\SqrState[g]{(9,2)}{11}%
%\SqrState[h]{(11,2)}{12}%
\State[3]{(2,4)}{3}%
\State[6]{(6,4)}{6}%
\State[8]{(10,4)}{8}%
%\SqrState[i]{(12,4)}{13}%
\State[2]{(4,6)}{2}%
\State[5]{(11,6)}{5}%
\State[1]{(8,8)}{1}%
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{solid}
\EdgeL[.5]{1}{2}{}
\EdgeL[.5]{2}{3}{}
\VCurveR[0.5]{angleA=90,angleB=2,ncurv=1.2}{5}{1}{}
\VArcR[.5]{arcangle=60,ncurv=0.7}{3}{1}{}
\ArcR[.5]{6}{1}{}
%\EdgeL[.5]{8}{11}{}
%\EdgeL[.5]{4}{14}{}
%\EdgeL[.5]{7}{16}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
%\ChgEdgeLineStyle{solid}
\ChgEdgeLineStyle{dashed}
\EdgeL[.5]{1}{5}{}
\EdgeL[.5]{2}{6}{}
%\EdgeL[.5]{5}{13}{}
%\EdgeL[.5]{3}{9}{}
%\EdgeL[.5]{6}{10}{}
%\EdgeL[.5]{8}{12}{}
%\EdgeL[.5]{4}{15}{}
%\EdgeL[.5]{7}{17}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{solid}
\VArcR[.5]{arcangle=70,ncurv=1.3}{4}{1}{}
\VCurveR[0.5]{angleA=0,angleB=30,ncurv=1.9}{8}{1}{}
\VCurveR[0.5]{angleA=-10,angleB=40,ncurv=3.3}{7}{1}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
%\ChgEdgeLineStyle{solid}
\ChgEdgeLineStyle{dashed}
\VArcR[.5]{arcangle=90,ncurv=1.3}{4}{1}{}
\EdgeL[.5]{3}{4}{}
\EdgeL[.5]{6}{7}{}
\EdgeL[.5]{5}{8}{}
\VCurveR[0.5]{angleA=-10,angleB=40,ncurv=2.2}{8}{1}{}
\VCurveR[0.5]{angleA=-20,angleB=50,ncurv=3.7}{7}{1}{}
%\VArcR[.5]{arcangle=50,ncurv=1.2}{5}{1}{}
%\VArcR[.5]{arcangle=50,ncurv=1.5}{8}{1}{}
}
\end{VCPicture}%
}
