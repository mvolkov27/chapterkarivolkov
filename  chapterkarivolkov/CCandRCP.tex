\documentclass{irmaart}
\input{ha.sty}
%========== gastex =====================================
\usepackage{gastex}
%========== vaucanson =====================================
\usepackage{vaucanson-g}
\ChgStateLineWidth{0.5}
\ChgEdgeLineWidth{0.5}

\newcommand{\SqrState}[3][]%
 {\StateStyle %
  \psset{framearc=0}%
  \settowidth{\VariableStateWidth}{\scalebox{\StateLabelSca}{\scalebox{\StateLabelScale}{$#1$}}}%
  \addtolength{\VariableStateWidth}{\ExtraSpace}
  \ifthenelse{\lengthtest{\VariableStateWidth < \VariableStateIntDiam}}%
        {\setlength{\VariableStateWidth}{\VariableStateIntDiam}}{}%
  \setlength{\VariableStateITPos}{\ArrowOnStateCoef\StateDiam}%
  \addtolength{\VariableStateITPos}{0.5\VariableStateWidth}%
  \addtolength{\VariableStateITPos}{-0.5\StateDiam}%
  \rput#2{\pnode(\VariableStateITPos,0){#3e}%
          \pnode(-\VariableStateITPos,0){#3w}%
          \pnode(0,\ArrowOnStateCoef\StateDiam){#3n}%
          \pnode(0,-\ArrowOnStateCoef\StateDiam){#3s}}%
  \rput#2{\rnode{#3}{\psframebox{\protect\rule[-.5\VariableStateIntDiam]{0pt}{\VariableStateIntDiam}\protect\rule{\VariableStateWidth}{0pt}}}}
  \rput#2{\VaucStateRBLabel{#1}}%
}%
%========== Shows labels refs linenumbers ==============
\usepackage[displaymath]{lineno}
\usepackage[notcite]{showkeys}
     \linenumbers
%========== Hyperref at the end ========================
\usepackage[hypertex,hyperindex,pagebackref,final]{hyperref}
%========== Time calculation ==============================
\usepackage{calc}
\newcounter{hours}\newcounter{minutes}
\newcommand\printtime{\setcounter{hours}{\time/60}%
  \setcounter{minutes}{\time-\value{hours}*60}%
  \thehours\,h\,\theminutes}
\newcommand\dateandtime{\today\quad\printtime}
%========== Algorithms ====================================
\usepackage[boxed]{algorithm}    % pour les floats algorithmes
\usepackage[noend]{algorithmic}  % pour les algorithmes
  \newlength\commentspace
  \setlength{\commentspace}{3cm}
  \newcommand\algcomment[2]{\makebox[0pt][l]{\hspace{-#1em}%
    \hspace{\commentspace}$\triangleright$ #2}}
\newcommand{\algorithmicfunc}[1]{\textsc{#1}}
\newcommand{\FUNC}[1]{\item[\algorithmicfunc{#1}]}
%========== PSTricks =====================================
\usepackage{pst-all}
 \newpsobject{showgrid}{psgrid}{%
  subgriddiv=1,griddots=10,gridlabels=6pt}
%========== Proofs =====================================
%------------- end of proof in equation -------
\newcommand{\eqed}{\tag*{\qedsymbol}}
%========== Math notations ===================================
\newcommand{\Card}{\operatorname{Card}}
\newcommand\A{\mathcal{A}}
\newcommand\B{\mathcal{B}}
\newcommand\Tau{T}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{\mathcal{T}}
\newcommand{\cU}{\mathcal{U}}
\newcommand{\cW}{\mathcal{W}}
\newcommand\e{\varepsilon}

%========== Shortcuts =============================
\newcommand{\sa}{synchronizing au\-tom\-a\-ta}
\newcommand{\san}{synchronizing au\-tom\-a\-ton}
\newcommand{\sw}{reset word}
\newcommand{\sws}{reset words}
%========== Hyphenation =============================

%====================================================
\begin{document}
%========== Headers =============================
\markboth{J.~Kari, M.~Volkov}{\v{C}ern\'{y}'s conjecture and the road coloring problem}

%=====================================================
\title{\v{C}ern\'{y}'s conjecture and the road coloring problem}
\author{Jarkko Kari$^1$,
  Mikhail Volkov$^2$}
\address{$^1$Department of Mathematics\\
FI-20014 University of Turku\\
Turku, Finland\\[2mm]
$^2$Department of Mathematics and Mechanics\\
620083 Ural State University\\
Ekaterinburg, Russia\\
email:\,\url{jkari@utu.fi,Mikhail.Volkov@usu.ru}\\[4mm]
\upshape{\dateandtime}}

%=====================================================
\maketitle\label{chapterKV}
%=====================================================

\begin{classification}
  68Q45
\end{classification}

\begin{keywords}
  Finite automata, Synchronizing automata, Reset words, \v{C}ern\'{y}'s conjecture,
  Road Coloring Problem
\end{keywords}



%==================================================
%Abstract
%\input{0-Abstract}
%Table of contents
\localtableofcontents

%=====================================================
\section{Synchronizing automata, their origins and importance}
%=====================================================
A complete deterministic finite automaton (DFA) $\mathcal{A}$
with input alphabet $A$ and state set $Q$ is called
\emph{synchronizing}\index{automaton!synchronizing} if there
exists a word $w\in A^*$ whose action resets $\mathcal{A}$, that
is, $w$ leaves the automaton in one particular state no matter
at which state in $Q$ it is applied: $q\cdot w=q'\cdot w$ for all
$q,q'\in Q$. Any word $w$ with this property is said to be a
\emph{reset}\index{reset word} word for the automaton.

\begin{figure}[ht]
\begin{center}
\begin{picture}(50,45)(-15,-10)
\node(A)(0,20){0} \node(B)(20,20){1} \node(C)(20,0){2}
\node(D)(0,0){3} \drawedge(A,B){$a,b$} \drawedge(B,C){$b$}
\drawedge(C,D){$b$} \drawedge(D,A){$b$}
\drawloop[loopangle=45](B){$a$} \drawloop[loopangle=-45](C){$a$}
\drawloop[loopangle=-135](D){$a$}
\end{picture}
\caption{A synchronizing automaton}\label{KV:fig:C4}
\end{center}
\end{figure}
Figure~\ref{KV:fig:C4} shows an example of a \san\ with 4~states.
The reader can easily verify that the word $ab^3ab^3a$ resets the
automaton leaving it in the state 1. With somewhat more effort one
can also check that $ab^3ab^3a$ is the shortest reset word for
this automaton. The example in Figure~\ref{KV:fig:C4} is due to
\v{C}ern\'{y}, a Slovak computer scientist, in whose pioneering
paper~\cite{Cerny:1964} the notion of a \san\ explicitly appeared
for the first time. (\v{C}ern\'{y} called such automata
\emph{directable}.  The word \emph{synchronizing} in this context
was probably introduced by Hennie~\cite{Hennie:1964}.
\marginpar{\textbf{Needs double-checking!!}}) Implicitly, however,
this concept has been around since the earliest days of automata
theory.  The very first \san\ that we were able to trace back in
the literature appeared in Ashby's classic book~\cite[pp.\,60--61]{Ashby:1956}.

In~\cite{Cerny:1964} the notion of a \san\ arose within the
classic framework of Moore's
``Gedanken-experiments''~\cite{Moore:1956}. For Moore and his
followers finite automata served as a mathematical model of
devices working in discrete mode, such as computers or relay
control systems. This leads to the following natural problem: how
can we restore control over such a device if we do not know its
current state but can observe outputs produced by the device under
various actions? Moore~\cite{Moore:1956} has shown that under
certain conditions one can uniquely determine the state at which
the automaton arrives after a suitable sequence of actions (called
an \emph{experiment}). Moore's experiments were adaptive, that is,
each next action was selected on the basis of the outputs caused
by the previous actions. Ginsburg~\cite{Ginsburg:1958} considered
more restricted experiments that he called \emph{uniform}. A
uniform experiment\footnote{After \cite{Gill:1961}, the name
\emph{homing sequence} has become standard for the notion.} is
just a fixed sequence of actions, that is, a word over the input
alphabet; thus, in Ginsburg's experiments outputs were only used
for calculating the resulting state at the end of an experiment.
From this, just one further step was needed to come to the setting
in which outputs were not used at all. It should be noted that
this setting is by no means artificial---there exist many
practical situations when it is technically impossible to observe
output signals. (Think of a satellite which loops around the Moon
and cannot be controlled from the Earth while ``behind'' the
Moon.)

The original ``Gedanken-experiments'' motivation for studying \sa\
is still of importance, and reset words are frequently applied in
model-based testing of reactive systems. See \cite{Cho&Jeong&Somenzi&Pixley:1993,
Boppana&Rajan&Takayama&Fujita:1999} as typical samples of technical
contributions to the area and \cite{Sandberg:2005} for a recent survey.

Another stong motivation comes from the coding theory. We refer to
\cite[Chapters~3 and~10]{Berstel&Perrin&Reutenauer:2009} for a detailed
account of profound connections between codes and automata; here we
restrict ourselves to a brief introduction into a special (but still
very important) case of maximal prefix codes. Recall that a \emph{prefix
code}\index{prefix code} over a finite alphabet $A$ is a set $X$ of words
in $A^*$ such that no word of $X$ is a prefix of another word of $X$.
A prefix code is \emph{maximal}\index{prefix code!maximal} if it is
not contained in another prefix code over the same alphabet. A maximal
prefix code $X$ over $A$ is \emph{synchronized}\index{prefix code!synchronized}
if there is a word $x\in X^*$ such that for any word $w\in A^*$, one has $wx\in X^*$.
Such a word $x$ is called a \emph{synchronizing word}\index{synchronizing word
of a code} for $X$. The advantage of synchronized codes is that they are able
to recover after a loss of synchronization between the decoder and the coder
caused by channel errors: in the case of such a loss, it suffices to transmit
a synchronizing word and the following symbols will be decoded correctly. Moreover,
since the probability that a word $v\in A^*$ contains a fixed word $x$ as a factor
tends to 1 when the length of $v$ increases, synchronized codes eventually
resynchronize by themselves, after sufficiently many symbols being sent.
(As shown in~\cite{Capocelli&Gargano&Vaccaro:1988}, the latter property in fact
characterizes synchronized codes.) The following simple example illustrates
these ideas: let $A=\{0,1\}$ and $X=\{000,0010,0011,010,0110,0111,10,110,111\}$.
Then $X$ is a maximal prefix code and one can easily check that each of the words
010, 011110, 011111110, \dots\ is a synchronizing word for $X$. For instance,
if the code word 000 has been sent but, due to a channel error, the word 100
has been received, the decoder interprets 10 as a code word, and thus, loses
synchronization. However, with a high probability this synchronization loss
only propagates for a short while; in particular, the decoder definitely
resynchronizes as soon as it encounters one of the segments 010, 011110, 011111110, \dots\
in the received stream of symbols. A few samples of such streams are shown
in Figure~\ref{KV:fig:decoding} in which vertical lines show the partition
of each stream into code words and the boldfaced code words indicate
the position at which the decoder resynchronizes.
\begin{figure}[h]
\begin{center}
\begin{tabular}{ll}
Sent & $0\,0\,0\ \mid 0\,0\,1\,0\,\ \mid\mathbf{0\,1\,1\,1\mid\dots}$\\
\mathstrut Received & $1\,0\mid 0\,0\,0 \mid 1\,0 \mid\mathbf{0\,1\,1\,1\mid\dots}$\\
\hline
\mathstrut Sent & $0\,0\,0\mid 0\,1\,1\,1 \mid 1\,1\,0\mid 0\,0\,1\,1 \mid 0\,0\,0 \mid 1\,0 \mid\mathbf{1\,1\,0\mid \dots}$\\
\mathstrut Received & $1\,0\mid 0\,0\,1\,1 \mid 1\,1\,1 \mid 0\,0\,0\mid 1\,1\,0 \mid 0\,0\,1\,0 \mid\mathbf{1\,1\,0\mid \dots}$\\
\hline
\mathstrut Sent & $0\,0\,0\mid 0\,0\,0 \mid 1\,1\,1\mid\mathbf{1\,0\mid \dots}$\\
\mathstrut Received & $1\,0\mid 0\,0\,0 \mid 0\,1\,1\,1 \mid\mathbf{1\,0\mid \dots}$
\end{tabular}
\caption{Restoring synchronization}\label{KV:fig:decoding}
\end{center}
\end{figure}

If $X$ is a finite prefix code over a finite alphabet $A$, then its decoding
can be implemented by a deterministic automaton that is defined as follows.
Let $Q$ be the set of all proper prefixes of the words in $X$ (including the empty word
$\varepsilon$). For $q\in Q$ and $a\in A$, define
\begin{displaymath}
q\cdot a =\begin{cases} qa & \text{if $qa$ is a proper prefix of a word of $X$}\,,\\
\varepsilon & \text{if $qa \in X$}\,.\end{cases}
\end{displaymath}
The resulting automaton $\mathcal{A}_X$ is complete whenever the code $X$
is maximal and it is easy to see that $\mathcal{A}_X$ is a \san\ if and only
if $X$ is a synchronized code. Moreover, a word $x$ is synchronizing for $X$
if and only if $x$ is a \sw\ for $\mathcal{A}_X$ and sends all states in $Q$
to the state $\varepsilon$. Figure~\ref{KV:fig:huffman} illustrates this construction
for the code $X=\{000,0010,0011,010,0110,0111,10,110,111\}$ considered above.
The solid/dashed lines correspond to (the action of) 0/1.
\begin{figure}[htbp]
\FixVCScale{0.4}
\VCDraw{%
\begin{VCPicture}{(0,-1)(16,9)}
\MediumState
\ChgEdgeArrowWidth{6.5pt}
\VCPut{(0,0)}{
 \RstStateFillColor
\SqrState[0010]{(2,0)}{14}%
\SqrState[0011]{(4,0)}{15}%
\SqrState[0110]{(6,0)}{16}%
\SqrState[0111]{(8,0)}{17}%
\StateVar[001]{(3,2)}{4}%
\SqrState[000]{(1,2)}{9}%
\StateVar[011]{(7,2)}{7}%
\SqrState[010]{(5,2)}{10}%
\SqrState[110]{(11,2)}{11}%
\SqrState[111]{(13,2)}{12}%
\State[00]{(2,4)}{3}%
\State[01]{(6,4)}{6}%
\State[11]{(12,4)}{8}%
\SqrState[10]{(10,4)}{13}%
\State[0]{(4,6)}{2}%
\State[1]{(11,6)}{5}%
\State[\varepsilon]{(8,8)}{1}%
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{solid}
\EdgeL[.5]{1}{2}{}
\EdgeL[.5]{2}{3}{}
\EdgeL[.5]{5}{13}{}
\EdgeL[.5]{3}{9}{}
\EdgeL[.5]{6}{10}{}
\EdgeL[.5]{8}{11}{}
\EdgeL[.5]{4}{14}{}
\EdgeL[.5]{7}{16}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{dashed}
\EdgeL[.5]{1}{5}{}
\EdgeL[.5]{2}{6}{}
\EdgeL[.5]{8}{12}{}
\EdgeL[.5]{4}{15}{}
\EdgeL[.5]{7}{17}{}
\EdgeL[.5]{5}{8}{}
\EdgeL[.5]{3}{4}{}
\EdgeL[.5]{6}{7}{}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\VCPut{(17,-2)}{
 \RstStateFillColor
\State[00]{(2,4)}{3}%
\State[01]{(6,4)}{6}%
\State[11]{(12,4)}{8}%
\StateVar[001]{(3,2)}{4}%
\StateVar[011]{(7,2)}{7}%
\State[0]{(4,6)}{2}%
\State[1]{(11,6)}{5}%
\State[\varepsilon]{(8,8)}{1}%
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{solid}
\EdgeL[.5]{1}{2}{}
\EdgeL[.5]{2}{3}{}
\VCurveR[0.5]{angleA=90,angleB=2,ncurv=1.2}{5}{1}{}
\VArcR[.5]{arcangle=60,ncurv=0.7}{3}{1}{}
\ArcR[.5]{6}{1}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{dashed}
\EdgeL[.5]{1}{5}{}
\EdgeL[.5]{2}{6}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{solid}
\VCurveR[0.5]{angleA=140,angleB=140,ncurv=1.6}{4}{1}{}
\VCurveR[0.5]{angleA=20,angleB=50,ncurv=.9}{8}{1}{}
\VCurveR[0.5]{angleA=25,angleB=-74,ncurv=.6}{7}{1}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{dashed}
\EdgeL[.5]{3}{4}{}
\EdgeL[.5]{6}{7}{}
\EdgeL[.5]{5}{8}{}
\VCurveR[0.5]{angleA=170,angleB=120,ncurv=1.9}{4}{1}{}
\VCurveR[0.5]{angleA=10,angleB=76,ncurv=1.2}{8}{1}{}
\VCurveR[0.5]{angleA=15,angleB=-56,ncurv=.8}{7}{1}{}
}
\end{VCPicture}%
}
\caption{A synchronized code (on the left) and its automaton (on the right)}\label{KV:fig:huffman}
\end{figure}

Thus, \textbf{(to be continued and supplied by some historical
references).}

An additional source of problems related to \sa\ has come from
\emph{robotics} or, more precisely, from part handling problems
in industrial automation such as part feeding, fixturing, loading,
assembly and packing. Within this framework, the concept of a \san\
was again rediscovered in the mid-1980s by Natarajan \cite{Natarajan:1986,
Natarajan:1989} who showed how \sa\ can be used to design sensor-free
orienters for polygonal parts, see \cite[Section~1]{Volkov:2008} for
a transparent example illustrating Natarajan's approach in a nutshell.
Since the 1990s \sa\ usage in the area of robotic manipulation has grown
into a prolific research direction but it is fair to say that publications
in this area deal mostly with implementation technicalities. However,
amongst them there are papers of significant theoretical importance
such as \cite{Eppstein:1990,Goldberg:1993,Chen&Ierardi:1995}.

\section{Algorithmic and complexity issues}

It should be clear that not every DFA is synchronizing. Therefore,
the very first question that we should address is the following
one: \emph{given an automaton $\mathcal{A}$, how to determine
whether or not $\mathcal{A}$ is synchronizing?}

\begin{figure}[htb]
\begin{center}
\unitlength=.9mm
\begin{picture}(85,88)(-10,20)
\node(A)(-20,57){0} \node(B)(0,57){1} \node(C)(0,38){2}
\node(D)(-20,38){3} \drawedge(A,B){$a,b$} \drawedge(B,C){$b$}
\drawedge(C,D){$b$} \drawedge(D,A){$b$}
\drawloop[loopangle=45](B){$a$} \drawloop[loopangle=-45](C){$a$}
\drawloop[loopangle=-135](D){$a$} \node(AD)(20,38){03}
\node(AB)(20,57){01} \node(BC)(40,57){12} \node(CD)(40,38){23}
\node(AC)(60,57){02} \node(BD)(80,57){13}
\drawloop[loopangle=0](CD){$a$} \drawloop[loopangle=0](BD){$a$}
\drawloop[loopangle=45](BC){$a$}
\drawedge[linewidth=.5,AHLength=2,ELside=r](CD,AD){$b$}
\drawedge[linewidth=.5,AHLength=2](AD,AB){$b$}
\drawedge(AB,BC){$b$}
\drawedge[linewidth=.5,AHLength=2](BC,CD){$b$}
\drawedge[linewidth=.5,AHLength=2,curvedepth=5](AB,B){$a$}
\gasset{Nadjust=w,Nadjustdist=1.5,Nh=6,Nmr=2}
\node(ABC)(40,76){012} \node(ABD)(70,76){013}
\node(BCD)(40,95){123} \node(ACD)(70,95){023}
\node(ABCD)(10,95){0123} \drawloop(ABCD){$b$} \drawloop(BCD){$a$}
\drawedge[linewidth=.5,AHLength=2](ABCD,BCD){$a$}
\drawedge[linewidth=.5,AHLength=2,ELside=r](BCD,ACD){$b$}
\drawedge[curvedepth=-5,ELside=r](ACD,BCD){$a$}
\drawedge[linewidth=.5,AHLength=2](ACD,ABD){$b$}
\drawedge(ABC,BCD){$b$}
\drawedge[linewidth=.5,AHLength=2,ELside=r](ABD,ABC){$b$}
\drawedge[linewidth=.5,AHLength=2,curvedepth=-5,ELside=r](ABC,BC){$a$}
\drawedge[curvedepth=5](ABD,BD){$a$}
\drawedge[curvedepth=5](AC,BC){$a$}
\drawedge[curvedepth=5](BD,AC){$b$} \drawedge(AC,BD){$b$}
\drawedge[curvedepth=-20,ELside=r](AD,BD){$a$}
\end{picture}
\caption{The power automaton
$\mathcal{P}(\mathcal{C}_4$)}\label{KV:fig:power automaton}
\end{center}
\end{figure}

This question is in fact quite easy, and the most straightforward
solution to it can be achieved via the classic subset construction
by Rabin and Scott~\cite{Rabin&Scott:1959}. Given a DFA
$\mathcal{A}$ with input alphabet $A$ and state set $Q$, we define
its \emph{subset automaton}\index{subset automaton}
$\mathcal{P}(\mathcal{A})$ on the set of the non-empty subsets of
$Q$ by setting $P\cdot a=\{p\cdot a\mid p\in P\}$ for each
non-empty subset $P$ of $Q$ and each $a\in\A$. (Since we start
with a deterministic automaton, we do not need adding the empty
set to the state set of $\mathcal{P}(\mathcal{A})$.)
Figure~\ref{KV:fig:power automaton} presents the subset automaton
for the DFA $\mathcal{C}_4$ shown in Figure~\ref{KV:fig:C4}.

Now it is obvious that a word $w\in A^*$ is a reset word for the
DFA $\mathcal{A}$ if and only if $w$ labels a path in
$\mathcal{P}(\mathcal{A})$ starting at $Q$ and ending at a
singleton. (For instance, the bold path in
Figure~\ref{KV:fig:power automaton} represents the shortest reset
word $ab^3ab^3a$ of the automaton $\mathcal{C}_4$.) Thus, the
question of whether or not a given DFA $\mathcal{A}$ is
synchronizing reduces to the following reachability question in
the underlying digraph of the subset automaton
$\mathcal{P}(\mathcal{A})$: is there a path from $Q$ to a
singleton? The latter question can be easily answered by
breadth-first search,  see, e.g.,
\cite[Section~22.2]{Cormen&Leiserson&Rivest&Stein:2001}.

The described procedure is conceptually very simple but rather
inefficient because the power automaton $\mathcal{P}(\mathcal{A})$
is exponentially larger than $\mathcal{A}$. However, the following
criterion of synchronizability~\cite[Theorem~2]{Cerny:1964} gives
rise to a polynomial algorithm.
\begin{proposition}
\label{KV:prop:quadratic} A DFA $\mathcal{A}$ with input alphabet
$A$ and state set $Q$ is synchronizing if and only if for every
$q,q'\in Q$ there exists a word $w\in A^*$ such that $q\cdot
w=q'\cdot w$.
\end{proposition}
One can treat Proposition~\ref{KV:prop:quadratic} as a reduction
of the synchronizability problem to a reachability problem in the
subautomaton $\mathcal{P}^{[2]}(\mathcal{A})$ of
$\mathcal{P}(\mathcal{A})$ whose states are 2-element and
1-element subsets of $Q$. Since the subautomaton has
$\dfrac{|Q|(|Q|+1)}2$ states, breadth-first search solves this
problem in $O(|Q|^2\cdot|A|)$ time. This complexity bound assumes
that no reset word is explicitly calculated. If one requires that,
whenever $\mathcal{A}$ turns out to be synchronizing, a reset word
is produced, then the best of the known algorithms (which is
basically due to Eppstein \cite[Theorem~6]{Eppstein:1990}, see
also \cite[Theorem~1.15]{Sandberg:2005}) has an implementation
that consumes $O(|Q|^3 + |Q|^2\cdot|A|)$ time and $O(|Q|^2 +
|Q|\cdot|A|)$ working space, not counting the space for the output
which is $O(|Q|^3)$.

For a \san, the subset automaton can be used to construct shortest
reset words which correspond to shortest paths from the whole
state set to a singleton. Of course, this requires exponential (of
$|Q|$) time in the worst case. Nevertheless, there were attempts
to implement this approach, see, e.g.,
\cite{Rho&Somenzi&Pixley:1993,Trahtman:2006}. One may hope that,
as above, a suitable calculation in the ``polynomial''
subautomaton $\mathcal{P}^{[2]}(\mathcal{A})$ may yield a
polynomial algorithm. However, it is not the case, and moreover,
as we will see, it is very unlikely that any reasonable algorithm
may exist for finding shortest reset words in general \sa. In the
following discussion we assume the reader's acquaintance with some
basics of computational complexity (such as the definitions of the
complexity classes \textsf{NP} and \textsf{coNP}) that can be
found, e.g., in~\cite{Garey&Johnson:1979,Papadimitriou:1994}.

Consider the following decision problem:

\smallskip

\hangindent=\parindent \noindent\textsc{Short-Reset-Word:}
\emph{Given a \san\ $\mathcal{A}$ and a positive integer $\ell$,
is it true that $\mathcal{A}$ has a reset word of length $\ell$?}

\smallskip

Clearly, \textsc{Short-Reset-Word} belongs to the complexity class
\textsf{NP}: one can non-deterministically guess a word $w\in\A^*$
of length $\ell$ and then check if $w$ is a reset word for
$\mathcal{A}$ in time $\ell|Q|$. Several
authors~\cite{Rystsov:1980,Eppstein:1990,Goralcik&Koubek:1995,Salomaa:2003,Samotij:2007}
have proved that \textsc{Short-Reset-Word} is \textsf{NP}-hard by
a polynomial reduction from \textsc{SAT} (the satisfiability
problem for a system of clauses, that is, formulae in conjunctive
normal form). We reproduce here Eppstein's reduction
from~\cite{Eppstein:1990}.

\section{The \v{C}ern\'{y} conjecture}

\section{The road coloring problem}

\section{Generalizations}

\bibliographystyle{abbrv}
\addcontentsline{toc}{section}{References}
\begin{footnotesize}
  \bibliography{abbrevs,SA}
\end{footnotesize}


\addcontentsline{toc}{section}{Index}
\markright{\indexname}\markboth{\indexname}{\indexname}
\printindex

\end{document}

\hangindent=\parindent \noindent \textsc{Shortest-Reset-Word:}
\emph{Given a \san\ $\mathcal{A}$ and a positive integer $\ell$,
is it true that the minimum length of a reset word for
$\mathcal{A}$ is equal to $\ell$?}

\smallskip
