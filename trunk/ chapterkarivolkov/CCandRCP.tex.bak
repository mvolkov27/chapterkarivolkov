\documentclass{irmaart}
\input{ha.sty}
%========== gastex =====================================
\usepackage{gastex}
%========== vaucanson =====================================
\usepackage{vaucanson-g}
\ChgStateLineWidth{0.5}
\ChgEdgeLineWidth{0.5}

\newcommand{\SqrState}[3][]%
 {\StateStyle %
  \psset{framearc=0}%
  \settowidth{\VariableStateWidth}{\scalebox{\StateLabelSca}{\scalebox{\StateLabelScale}{$#1$}}}%
  \addtolength{\VariableStateWidth}{\ExtraSpace}
  \ifthenelse{\lengthtest{\VariableStateWidth < \VariableStateIntDiam}}%
        {\setlength{\VariableStateWidth}{\VariableStateIntDiam}}{}%
  \setlength{\VariableStateITPos}{\ArrowOnStateCoef\StateDiam}%
  \addtolength{\VariableStateITPos}{0.5\VariableStateWidth}%
  \addtolength{\VariableStateITPos}{-0.5\StateDiam}%
  \rput#2{\pnode(\VariableStateITPos,0){#3e}%
          \pnode(-\VariableStateITPos,0){#3w}%
          \pnode(0,\ArrowOnStateCoef\StateDiam){#3n}%
          \pnode(0,-\ArrowOnStateCoef\StateDiam){#3s}}%
  \rput#2{\rnode{#3}{\psframebox{\protect\rule[-.5\VariableStateIntDiam]{0pt}{\VariableStateIntDiam}\protect\rule{\VariableStateWidth}{0pt}}}}
  \rput#2{\VaucStateRBLabel{#1}}%
}%
%========== Shows labels refs linenumbers ==============
\usepackage[displaymath]{lineno}
\usepackage[notcite]{showkeys}
     \linenumbers
%========== Hyperref at the end ========================
\usepackage[hypertex,hyperindex,pagebackref,final]{hyperref}
%========== Time calculation ==============================
\usepackage{calc}
\newcounter{hours}\newcounter{minutes}
\newcommand\printtime{\setcounter{hours}{\time/60}%
  \setcounter{minutes}{\time-\value{hours}*60}%
  \thehours\,h\,\theminutes}
\newcommand\dateandtime{\today\quad\printtime}
%========== Algorithms ====================================
\usepackage[boxed]{algorithm}    % pour les floats algorithmes
\usepackage[noend]{algorithmic}  % pour les algorithmes
  \newlength\commentspace
  \setlength{\commentspace}{3cm}
  \newcommand\algcomment[2]{\makebox[0pt][l]{\hspace{-#1em}%
    \hspace{\commentspace}$\triangleright$ #2}}
\newcommand{\algorithmicfunc}[1]{\textsc{#1}}
\newcommand{\FUNC}[1]{\item[\algorithmicfunc{#1}]}
%========== PSTricks =====================================
\usepackage{pst-all}
 \newpsobject{showgrid}{psgrid}{%
  subgriddiv=1,griddots=10,gridlabels=6pt}
%========== Proofs =====================================
%------------- end of proof in equation -------
\newcommand{\eqed}{\tag*{\qedsymbol}}
%========== Math notations ===================================
\newcommand{\Card}{\operatorname{Card}}
\newcommand\A{\mathcal{A}}
\newcommand\B{\mathcal{B}}
\newcommand\Tau{T}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{\mathcal{T}}
\newcommand{\cU}{\mathcal{U}}
\newcommand{\cW}{\mathcal{W}}
\newcommand\e{\varepsilon}

%========== Shortcuts =============================
\newcommand{\sa}{synchronizing au\-tom\-a\-ta}
\newcommand{\san}{synchronizing au\-tom\-a\-ton}
\newcommand{\sw}{reset word}
\newcommand{\sws}{reset words}
%========== Hyphenation =============================

%====================================================
\begin{document}
%========== Headers =============================
\markboth{J.~Kari, M.~Volkov}{\v{C}ern\'{y}'s conjecture and the road coloring problem}

%=====================================================
\title{\v{C}ern\'{y}'s conjecture and the road coloring problem}
\author{Jarkko Kari$^1$,
  Mikhail Volkov$^2$}
\address{$^1$Department of Mathematics\\
FI-20014 University of Turku\\
Turku, Finland\\[2mm]
$^2$Department of Mathematics and Mechanics\\
620083 Ural State University\\
Ekaterinburg, Russia\\
email:\,\url{jkari@utu.fi,Mikhail.Volkov@usu.ru}\\[4mm]
\upshape{\dateandtime}}

%=====================================================
\maketitle\label{chapterKV}
%=====================================================

\begin{classification}
  68Q45 68R10
\end{classification}

\begin{keywords}
  Finite automata, Synchronizing automata, Reset words, \v{C}ern\'{y}'s conjecture,
  Road Coloring Problem
\end{keywords}



%==================================================
%Abstract
%\input{0-Abstract}
%Table of contents
\localtableofcontents

%=====================================================
\section{Synchronizing automata, their origins and importance}
%=====================================================
A complete deterministic finite automaton (DFA) $\mathcal{A}$
with input alphabet $A$ and state set $Q$ is called
\emph{synchronizing}\index{automaton!synchronizing} if there
exists a word $w\in A^*$ whose action resets $\mathcal{A}$, that
is, $w$ leaves the automaton in one particular state no matter
at which state in $Q$ it is applied: $q\cdot w=q'\cdot w$ for all
$q,q'\in Q$. Any word $w$ with this property is said to be a
\emph{reset}\index{reset word} word for the automaton.

\begin{figure}[ht]
\unitlength=.75mm
\begin{center}
\begin{picture}(50,40)(-15,-10)
\gasset{Nh=6,Nw=6,Nmr=3,loopdiam=6} \node(A)(0,20){0}
\node(B)(20,20){1} \node(C)(20,0){2} \node(D)(0,0){3}
\drawedge(A,B){$a,b$} \drawedge(B,C){$b$} \drawedge(C,D){$b$}
\drawedge(D,A){$b$} \drawloop[loopangle=45](B){$a$}
\drawloop[loopangle=-45](C){$a$} \drawloop[loopangle=-135](D){$a$}
\end{picture}
\caption{A synchronizing automaton}\label{KV:fig:C4}
\end{center}
\end{figure}
Figure~\ref{KV:fig:C4} shows an example of a \san\ with 4~states.
The reader can easily verify that the word $ab^3ab^3a$ resets the
automaton leaving it in the state 1. With somewhat more effort one
can also check that $ab^3ab^3a$ is the shortest reset word for
this automaton. The example in Figure~\ref{KV:fig:C4} is due to
\v{C}ern\'{y}, a Slovak computer scientist, in whose pioneering
paper~\cite{Cerny:1964} the notion of a \san\ explicitly appeared
for the first time. (\v{C}ern\'{y} called such automata
\emph{directable}.  The word \emph{synchronizing} in this context
was probably introduced by Hennie~\cite{Hennie:1964}.
\marginpar{\textbf{Needs double-checking!!}}) Implicitly, however,
this concept has been around since the earliest days of automata
theory. The very first \san\ that we were able to trace back in
the literature appeared in Ashby's classic
book~\cite[pp.\,60--61]{Ashby:1956}.

In~\cite{Cerny:1964} the notion of a \san\ arose within the
classic framework of Moore's
``Gedanken-experiments''~\cite{Moore:1956}. For Moore and his
followers finite automata served as a mathematical model of
devices working in discrete mode, such as computers or relay
control systems. This leads to the following natural problem: how
can we restore control over such a device if we do not know its
current state but can observe outputs produced by the device under
various actions? Moore~\cite{Moore:1956} has shown that under
certain conditions one can uniquely determine the state at which
the automaton arrives after a suitable sequence of actions (called
an \emph{experiment}). Moore's experiments were adaptive, that is,
each next action was selected on the basis of the outputs caused
by the previous actions. Ginsburg~\cite{Ginsburg:1958} considered
more restricted experiments that he called \emph{uniform}. A
uniform experiment\footnote{After \cite{Gill:1961}, the name
\emph{homing sequence} has become standard for the notion.} is
just a fixed sequence of actions, that is, a word over the input
alphabet; thus, in Ginsburg's experiments outputs were only used
for calculating the resulting state at the end of an experiment.
From this, just one further step was needed to come to the setting
in which outputs were not used at all. It should be noted that
this setting is by no means artificial---there exist many
practical situations when it is technically impossible to observe
output signals. (Think of a satellite which loops around the Moon
and cannot be controlled from the Earth while ``behind'' the
Moon.)

The original ``Gedanken-experiments'' motivation for studying \sa\
is still of importance, and reset words are frequently applied in
model-based testing of reactive systems. See \cite{Cho&Jeong&Somenzi&Pixley:1993,
Boppana&Rajan&Takayama&Fujita:1999} as typical samples of technical
contributions to the area and \cite{Sandberg:2005} for a recent survey.

Another strong motivation comes from the coding theory. We refer
to \cite[Chapters~3 and~10]{Berstel&Perrin&Reutenauer:2009} for a
detailed account of profound connections between codes and
automata; here we restrict ourselves to a special (but still very
important) case of maximal prefix codes. Recall that a
\emph{prefix code}\index{prefix code} over a finite alphabet $A$
is a set $X$ of words in $A^*$ such that no word of $X$ is a
prefix of another word of $X$. A prefix code is
\emph{maximal}\index{prefix code!maximal} if it is not contained
in another prefix code over the same alphabet. A maximal prefix
code $X$ over $A$ is \emph{synchronized}\index{prefix
code!synchronized} if there is a word $x\in X^*$ such that for any
word $w\in A^*$, one has $wx\in X^*$. Such a word $x$ is called a
\emph{synchronizing word}\index{synchronizing word of a code} for
$X$. The advantage of synchronized codes is that they are able to
recover after a loss of synchronization between the decoder and
the coder caused by channel errors: in the case of such a loss, it
suffices to transmit a synchronizing word and the following
symbols will be decoded correctly. Moreover, since the probability
that a word $v\in A^*$ contains a fixed factor $x$ tends to 1 as
the length of $v$ increases, synchronized codes eventually
resynchronize by themselves, after sufficiently many symbols being
sent. (As shown in~\cite{Capocelli&Gargano&Vaccaro:1988}, the
latter property in fact characterizes synchronized codes.) The
following simple example illustrates these ideas: let $A=\{0,1\}$
and $X=\{000,0010,0011,010,0110,0111,10,110,111\}$. Then $X$ is a
maximal prefix code and one can easily check that each of the
words 010, 011110, 011111110, \dots\ is a synchronizing word for
$X$. For instance, if the code word 000 has been sent but, due to
a channel error, the word 100 has been received, the decoder
interprets 10 as a code word, and thus, loses synchronization.
However, with a high probability this synchronization loss only
propagates for a short while; in particular, the decoder
definitely resynchronizes as soon as it encounters one of the
segments 010, 011110, 011111110, \dots\ in the received stream of
symbols. A few samples of such streams are shown in
Figure~\ref{KV:fig:decoding} in which vertical lines show the
partition of each stream into code words and the boldfaced code
words indicate the position at which the decoder resynchronizes.
\begin{figure}[h]
\begin{center}
\begin{tabular}{ll}
Sent & $0\,0\,0\ \mid 0\,0\,1\,0\,\ \mid\mathbf{0\,1\,1\,1\mid\dots}$\\
\mathstrut Received & $1\,0\mid 0\,0\,0 \mid 1\,0 \mid\mathbf{0\,1\,1\,1\mid\dots}$\\
\hline
\mathstrut Sent & $0\,0\,0\mid 0\,1\,1\,1 \mid 1\,1\,0\mid 0\,0\,1\,1 \mid 0\,0\,0 \mid 1\,0 \mid\mathbf{1\,1\,0\mid \dots}$\\
\mathstrut Received & $1\,0\mid 0\,0\,1\,1 \mid 1\,1\,1 \mid 0\,0\,0\mid 1\,1\,0 \mid 0\,0\,1\,0 \mid\mathbf{1\,1\,0\mid \dots}$\\
\hline
\mathstrut Sent & $0\,0\,0\mid 0\,0\,0 \mid 1\,1\,1\mid\mathbf{1\,0\mid \dots}$\\
\mathstrut Received & $1\,0\mid 0\,0\,0 \mid 0\,1\,1\,1 \mid\mathbf{1\,0\mid \dots}$
\end{tabular}
\caption{Restoring synchronization}\label{KV:fig:decoding}
\end{center}
\end{figure}

If $X$ is a finite prefix code over an alphabet $A$, then its
decoding can be implemented by a deterministic automaton that is
defined as follows. Let $Q$ be the set of all proper prefixes of
the words in $X$ (including the empty word $\varepsilon$). For
$q\in Q$ and $a\in A$, define
\begin{displaymath}
q\cdot a =\begin{cases} qa & \text{if $qa$ is a proper prefix of a word of $X$}\,,\\
\varepsilon & \text{if $qa \in X$}\,.\end{cases}
\end{displaymath}
The resulting automaton $\mathcal{A}_X$ is complete whenever the code $X$
is maximal and it is easy to see that $\mathcal{A}_X$ is a \san\ if and only
if $X$ is a synchronized code. Moreover, a word $x$ is synchronizing for $X$
if and only if $x$ is a \sw\ for $\mathcal{A}_X$ and sends all states in $Q$
to the state $\varepsilon$. Figure~\ref{KV:fig:huffman} illustrates this construction
for the code $X=\{000,0010,0011,010,0110,0111,10,110,111\}$ considered above.
The solid/dashed lines correspond to (the action of) 0/1.
\begin{figure}[htbp]
\FixVCScale{0.4}
\VCDraw{%
\begin{VCPicture}{(0,-1)(16,9)}
\MediumState
\ChgEdgeArrowWidth{6.5pt}
\VCPut{(0,0)}{
 \RstStateFillColor
\SqrState[0010]{(2,0)}{14}%
\SqrState[0011]{(4,0)}{15}%
\SqrState[0110]{(6,0)}{16}%
\SqrState[0111]{(8,0)}{17}%
\StateVar[001]{(3,2)}{4}%
\SqrState[000]{(1,2)}{9}%
\StateVar[011]{(7,2)}{7}%
\SqrState[010]{(5,2)}{10}%
\SqrState[110]{(11,2)}{11}%
\SqrState[111]{(13,2)}{12}%
\State[00]{(2,4)}{3}%
\State[01]{(6,4)}{6}%
\State[11]{(12,4)}{8}%
\SqrState[10]{(10,4)}{13}%
\State[0]{(4,6)}{2}%
\State[1]{(11,6)}{5}%
\State[\varepsilon]{(8,8)}{1}%
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{solid}
\EdgeL[.5]{1}{2}{}
\EdgeL[.5]{2}{3}{}
\EdgeL[.5]{5}{13}{}
\EdgeL[.5]{3}{9}{}
\EdgeL[.5]{6}{10}{}
\EdgeL[.5]{8}{11}{}
\EdgeL[.5]{4}{14}{}
\EdgeL[.5]{7}{16}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{dashed}
\EdgeL[.5]{1}{5}{}
\EdgeL[.5]{2}{6}{}
\EdgeL[.5]{8}{12}{}
\EdgeL[.5]{4}{15}{}
\EdgeL[.5]{7}{17}{}
\EdgeL[.5]{5}{8}{}
\EdgeL[.5]{3}{4}{}
\EdgeL[.5]{6}{7}{}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\VCPut{(17,-2)}{
 \RstStateFillColor
\State[00]{(2,4)}{3}%
\State[01]{(6,4)}{6}%
\State[11]{(12,4)}{8}%
\StateVar[001]{(3,2)}{4}%
\StateVar[011]{(7,2)}{7}%
\State[0]{(4,6)}{2}%
\State[1]{(11,6)}{5}%
\State[\varepsilon]{(8,8)}{1}%
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{solid}
\EdgeL[.5]{1}{2}{}
\EdgeL[.5]{2}{3}{}
\VCurveR[0.5]{angleA=90,angleB=2,ncurv=1.2}{5}{1}{}
\VArcR[.5]{arcangle=60,ncurv=0.7}{3}{1}{}
\ArcR[.5]{6}{1}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{dashed}
\EdgeL[.5]{1}{5}{}
\EdgeL[.5]{2}{6}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{solid}
\VCurveR[0.5]{angleA=140,angleB=140,ncurv=1.6}{4}{1}{}
\VCurveR[0.5]{angleA=20,angleB=50,ncurv=.9}{8}{1}{}
\VCurveR[0.5]{angleA=25,angleB=-74,ncurv=.6}{7}{1}{}
\ChgEdgeLineWidth{2}
\ChgEdgeLineColor{black}
\ChgEdgeLineStyle{dashed}
\EdgeL[.5]{3}{4}{}
\EdgeL[.5]{6}{7}{}
\EdgeL[.5]{5}{8}{}
\VCurveR[0.5]{angleA=170,angleB=120,ncurv=1.9}{4}{1}{}
\VCurveR[0.5]{angleA=10,angleB=76,ncurv=1.2}{8}{1}{}
\VCurveR[0.5]{angleA=15,angleB=-56,ncurv=.8}{7}{1}{}
}
\end{VCPicture}%
}
\caption{A synchronized code (on the left) and its automaton (on the right)}\label{KV:fig:huffman}
\end{figure}

Thus, \textbf{(to be continued and supplied by some historical
references).}

An additional source of problems related to \sa\ has come from
\emph{robotics} or, more precisely, from part handling problems
in industrial automation such as part feeding, fixturing, loading,
assembly and packing. Within this framework, the concept of a \san\
was again rediscovered in the mid-1980s by Natarajan \cite{Natarajan:1986,
Natarajan:1989} who showed how \sa\ can be used to design sensor-free
orienters for polygonal parts, see \cite[Section~1]{Volkov:2008} for
a transparent example illustrating Natarajan's approach in a nutshell.
Since the 1990s \sa\ usage in the area of robotic manipulation has grown
into a prolific research direction but it is fair to say that publications
in this area deal mostly with implementation technicalities. However,
amongst them there are papers of significant theoretical importance
such as \cite{Eppstein:1990,Goldberg:1993,Chen&Ierardi:1995}.

\section{Algorithmic and complexity issues}

It should be clear that not every DFA is synchronizing. Therefore,
the very first question that we should address is the following
one: \emph{given an automaton $\mathcal{A}$, how to determine
whether or not $\mathcal{A}$ is synchronizing?}

\begin{figure}[htb]
\begin{center}
\unitlength=.75mm
\begin{picture}(85,80)(-10,25)
\gasset{Nh=6,Nw=6,Nmr=3,loopdiam=6} \node(A)(-20,57){0}
\node(B)(0,57){1} \node(C)(0,38){2} \node(D)(-20,38){3}
\drawedge(A,B){$a,b$} \drawedge(B,C){$b$} \drawedge(C,D){$b$}
\drawedge(D,A){$b$} \drawloop[loopangle=45](B){$a$}
\drawloop[loopangle=-45](C){$a$} \drawloop[loopangle=-135](D){$a$}
\node(AD)(20,38){03} \node(AB)(20,57){01} \node(BC)(40,57){12}
\node(CD)(40,38){23} \node(AC)(60,57){02} \node(BD)(80,57){13}
\drawloop[loopangle=0](CD){$a$} \drawloop[loopangle=0](BD){$a$}
\drawloop[loopangle=45](BC){$a$}
\drawedge[linewidth=.5,AHLength=2,ELside=r](CD,AD){$b$}
\drawedge[linewidth=.5,AHLength=2](AD,AB){$b$}
\drawedge(AB,BC){$b$}
\drawedge[linewidth=.5,AHLength=2](BC,CD){$b$}
\drawedge[linewidth=.5,AHLength=2,curvedepth=5](AB,B){$a$}
\gasset{Nadjust=w,Nadjustdist=1.5,Nh=6,Nmr=2}
\node(ABC)(40,76){012} \node(ABD)(70,76){013}
\node(BCD)(40,95){123} \node(ACD)(70,95){023}
\node(ABCD)(10,95){0123} \drawloop(ABCD){$b$} \drawloop(BCD){$a$}
\drawedge[linewidth=.5,AHLength=2](ABCD,BCD){$a$}
\drawedge[linewidth=.5,AHLength=2,ELside=r](BCD,ACD){$b$}
\drawedge[curvedepth=-5,ELside=r](ACD,BCD){$a$}
\drawedge[linewidth=.5,AHLength=2](ACD,ABD){$b$}
\drawedge(ABC,BCD){$b$}
\drawedge[linewidth=.5,AHLength=2,ELside=r](ABD,ABC){$b$}
\drawedge[linewidth=.5,AHLength=2,curvedepth=-5,ELside=r](ABC,BC){$a$}
\drawedge[curvedepth=5](ABD,BD){$a$}
\drawedge[curvedepth=5](AC,BC){$a$}
\drawedge[curvedepth=5](BD,AC){$b$} \drawedge(AC,BD){$b$}
\drawedge[curvedepth=-20,ELside=r](AD,BD){$a$}
\end{picture}
\caption{The power automaton
$\mathcal{P}(\mathcal{C}_4$)}\label{KV:fig:power automaton}
\end{center}
\end{figure}

This question is in fact quite easy, and the most straightforward
solution to it can be achieved via the classic subset construction
by Rabin and Scott~\cite{Rabin&Scott:1959}. Given a DFA
$\mathcal{A}$ with input alphabet $A$ and state set $Q$, we define
its \emph{subset automaton}\index{subset automaton}
$\mathcal{P}(\mathcal{A})$ on the set of the non-empty subsets of
$Q$ by setting $P\cdot a=\{p\cdot a\mid p\in P\}$ for each
non-empty subset $P$ of $Q$ and each $a\in\A$. (Since we start
with a deterministic automaton, we do not need adding the empty
set to the state set of $\mathcal{P}(\mathcal{A})$.)
Figure~\ref{KV:fig:power automaton} presents the subset automaton
for the DFA $\mathcal{C}_4$ shown in Figure~\ref{KV:fig:C4}.

Now it is obvious that a word $w\in A^*$ is a reset word for the
DFA $\mathcal{A}$ if and only if $w$ labels a path in
$\mathcal{P}(\mathcal{A})$ starting at $Q$ and ending at a
singleton. (For instance, the bold path in
Figure~\ref{KV:fig:power automaton} represents the shortest reset
word $ab^3ab^3a$ of the automaton $\mathcal{C}_4$.) Thus, the
question of whether or not a given DFA $\mathcal{A}$ is
synchronizing reduces to the following reachability question in
the underlying digraph of the subset automaton
$\mathcal{P}(\mathcal{A})$: is there a path from $Q$ to a
singleton? The latter question can be easily answered by
breadth-first search,  see, e.g.,
\cite[Section~22.2]{Cormen&Leiserson&Rivest&Stein:2001}.

The described procedure is conceptually very simple but rather
inefficient because the power automaton $\mathcal{P}(\mathcal{A})$
is exponentially larger than $\mathcal{A}$. However, the following
criterion of synchronizability~\cite[Theorem~2]{Cerny:1964} gives
rise to a polynomial algorithm.
\begin{proposition}
\label{KV:prop:quadratic} A DFA $\mathcal{A}$ with input alphabet
$A$ and state set $Q$ is synchronizing if and only if for every
$q,q'\in Q$ there exists a word $w\in A^*$ such that $q\cdot
w=q'\cdot w$.
\end{proposition}
One can treat Proposition~\ref{KV:prop:quadratic} as a reduction
of the synchronizability problem to a reachability problem in the
subautomaton $\mathcal{P}^{[2]}(\mathcal{A})$ of
$\mathcal{P}(\mathcal{A})$ whose states are 2-element and
1-element subsets of $Q$. Since the subautomaton has
$\dfrac{|Q|(|Q|+1)}2$ states, breadth-first search solves this
problem in $O(|Q|^2\cdot|A|)$ time. This complexity bound assumes
that no reset word is explicitly calculated. If one requires that,
whenever $\mathcal{A}$ turns out to be synchronizing, a reset word
is produced, then the best of the known algorithms (which is
basically due to Eppstein \cite[Theorem~6]{Eppstein:1990}, see
also \cite[Theorem~1.15]{Sandberg:2005}) has an implementation
that consumes $O(|Q|^3 + |Q|^2\cdot|A|)$ time and $O(|Q|^2 +
|Q|\cdot|A|)$ working space, not counting the space for the output
which is $O(|Q|^3)$.

For a \san, the subset automaton can be used to construct shortest
reset words which correspond to shortest paths from the whole
state set $Q$ to a singleton. Of course, this requires exponential
(of $|Q|$) time in the worst case. Nevertheless, there were
attempts to implement this approach, see, e.g.,
\cite{Rho&Somenzi&Pixley:1993,Trahtman:2006}. One may hope that,
as above, a suitable calculation in the ``polynomial''
subautomaton $\mathcal{P}^{[2]}(\mathcal{A})$ may yield a
polynomial algorithm. However, it is not the case, and moreover,
as we will see, it is very unlikely that any reasonable algorithm
may exist for finding shortest reset words in general \sa. In the
following discussion we assume the reader's acquaintance with some
basics of computational complexity (such as the definitions of the
complexity classes \textsf{NP} and \textsf{coNP}) that can be
found, e.g., in~\cite{Garey&Johnson:1979,Papadimitriou:1994}.

Consider the following decision
problem:\index{\textsc{Short-Reset-Word}}

\smallskip

\hangindent=\parindent \noindent\textsc{Short-Reset-Word:}
\emph{Given a \san\ $\mathcal{A}$ and a positive integer $\ell$,
is it true that $\mathcal{A}$ has a reset word of length $\ell$?}

\smallskip

Clearly, \textsc{Short-Reset-Word} belongs to the complexity class
\textsf{NP}: one can non-deterministically guess a word $w\in A^*$
of length $\ell$ and then check if $w$ is a reset word for
$\mathcal{A}$ in time $\ell|Q|$. Several
authors~\cite{Rystsov:1980,Eppstein:1990,Goralcik&Koubek:1995,Salomaa:2003,Samotij:2007}
have proved that \textsc{Short-Reset-Word} is \textsf{NP}-hard by
a polynomial reduction from \textsc{SAT} (the satisfiability
problem for a system of \emph{clauses}, that is, disjunctions of
literals). We reproduce here Eppstein's reduction
from~\cite{Eppstein:1990}.

Given an arbitrary instance $\psi$ of \textsc{SAT} with $n$
variables $x_1,\dots,x_n$ and $m$ clauses $c_1,\dots,c_m$, we
construct a DFA $\mathcal{A}(\psi)$ with 2 input letters $a$ and
$b$ as follows. The state set $Q$ of $\mathcal{A}(\psi)$ consists
of $(n+1)m$ states $q_{i,j}$, $1 \le i \le m$, $1 \le j \le n+1$,
and a special state $z$. The transitions are defined by
\begin{align*}
& q_{i,j}\cdot a =
\begin{cases}
    z \text{ if the literal $x_j$ occurs in $c_i$},\\
    q_{i,j+1} \text{ otherwise}
\end{cases} && \text{ for $1 \le i \le m$, $1 \le j \le n$;} \\
&q_{i,j}\cdot b =
\begin{cases}
    z \text{ if the literal $\neg x_j$ occurs in $c_i$},\\
    q_{i,j+1} \text{ otherwise}
\end{cases} && \text{ for $1 \le i \le m$, $1 \le j \le n$;} \\
&q_{i,n+1}\cdot a=q_{i,n+1}\cdot b =z && \text{ for $1\le i\le
m$;}\\  &z\cdot a=z\cdot b =z.&&
\end{align*}
Figure~\ref{KV:fig:A2_example} shows two automata of the form
$\mathcal{A}(\psi)$ build for the \textsc{SAT} instances
\begin{align*}
\psi_1&=\{x_1 \vee x_2 \vee x_3,\, \neg x_1 \vee x_2,\, \neg x_2
\vee x_3,\,\neg x_2 \vee \neg x_3\},\\
\psi_2&=\{x_1 \vee x_2,\,\neg x_1 \vee x_2,\, \neg x_2 \vee
x_3,\,\neg x_2 \vee \neg x_3\}.
\end{align*}
If at some state $q\in Q$ in Figure~\ref{KV:fig:A2_example} there
is no outgoing edge labelled $c\in\{a,b\}$, the edge
$q\stackrel{c}{\to}z$ is assumed (those edges are omitted to
improve readability). The two instances differ only in the first
clause: in $\psi_1$ it contains the literal $x_3$ while in
$\psi_2$ it does not. Correspondingly, the automata
$\mathcal{A}(\psi_1)$ and $\mathcal{A}(\psi_2)$ differ only by the
outgoing edge labelled $a$ at the state $q_{1,3}$: in
$\mathcal{A}(\psi_1)$ it leads to $z$ (and therefore, it is not
shown) while in $\mathcal{A}(\psi_2)$ it leads to the state
$q_{1,4}$ and is shown by the dashed line.

Observe that $\psi_1$ is satisfiable for the truth assignment
$x_1=x_2=0$, $x_3=1$ while $\psi_2$ is not satisfiable. It is not
hard to check that the word $bba$ resets $\mathcal{A}(\psi_1)$
while $\mathcal{A}(\psi_2)$ is reset by no word of length~3 but by
every word of length~4.

\begin{figure}[t]
\unitlength=.75mm
\begin{center}
\begin{picture}(120,85)(-100,-10)
\node(n478)(-50,0){$q_{1,2}$} \node(n479)(10,0){$q_{1,4}$}
\node(n480)(-80,0){$q_{1,1}$} \node(n481)(-20,0){$q_{1,3}$}
\node(n75)(-50,20){$q_{2,2}$} \node(n32)(-20,20){$q_{2,3}$}
\node(n41)(10,20){$q_{2,4}$} \node(n202)(-80,20){$q_{2,1}$}
\node(n42)(10,40){$q_{3,4}$} \node(n172)(-80,40){$q_{3,1}$}
\node(n14)(-50,40){$q_{3,2}$} \node(n472)(-20,40){$q_{3,3}$}
\node(n474)(-50,60){$q_{4,2}$} \node(n475)(10,60){$q_{4,4}$}
\node(n476)(-80,60){$q_{4,1}$} \node(n477)(-20,60){$q_{4,3}$}

\drawedge(n480,n478){$b$} \drawedge(n478,n481){$b$}
\drawedge[ELdist=1.1](n32,n41){$a,b$} \drawedge(n472,n42){$b$}
\drawedge[ELdist=1.1,ELside=r](n476,n474){$a,b$}
\drawedge[ELside=r](n474,n477){$a$}
\drawedge[ELside=r](n477,n475){$a$} \drawedge(n202,n75){$a$}
\drawedge(n75,n32){$b$} \drawedge[ELdist=1.1](n172,n14){$a,b$}
\drawedge(n14,n472){$a$}

\node[Nw=8.32,Nh=7.0,Nmr=0.0](n1310)(-65,70){$x_1$}
\node[Nw=8.32,Nh=7.0,Nmr=0.0](n1316)(-35,70){$x_2$}
\node[Nw=8.32,Nh=7.0,Nmr=0.0](n1318)(-5,70){$x_3$}
\node[Nw=8.32,Nh=7.0,Nmr=0.0](n1367)(-95,0){$c_1$}
\node[Nw=8.32,Nh=7.0,Nmr=0.0](n1368)(-95,20){$c_2$}
\node[Nw=8.32,Nh=7.0,Nmr=0.0](n1369)(-95,40){$c_3$}
\node[Nw=8.32,Nh=7.0,Nmr=0.0](n1370)(-95,60){$c_4$}

\node(n1646)(30,30){$z$}

\drawedge[dash={3.0 3.0}{0.0},curvedepth=6](n481,n479){$a$ in
$\mathcal{A}(\psi_2)$}
\drawedge[curvedepth=-6,ELside=r,ELdist=2.0](n481,n479){$b$}
\end{picture}
\end{center}
\caption{The automata $\mathcal{A}(\psi_1)$ and
$\mathcal{A}(\psi_2)$} \label{KV:fig:A2_example}
\end{figure}

In general, it is easy to see that $\mathcal{A}(\psi)$ is reset by
every word of length $n+1$ and is reset by a word of length $n$ if
and only if $\psi$ is satisfiable. Therefore assigning the
instance $(\mathcal{A}(\psi),n)$ of \textsc{Short-Reset-Word} to
an arbitrary instance $\psi$ of \textsc{SAT}, one obtains a
polynomial reduction of the latter problem to the former. Since
\textsc{SAT} is \textsf{NP}-complete and \textsc{Short-Reset-Word}
lies in \textsf{NP}, we obtain the following.

\begin{proposition}
\label{KV:prop:complexity1} The problem \textsc{Short-Reset-Word}
is \textsf{NP}-complete.
\end{proposition}

In fact, as observed by Samotij~\cite{Samotij:2007}, the above
construction yields slightly more\footnote{Actually, the reduction
in~\cite{Samotij:2007} is not correct but the result claimed can
be easily recovered as shown below.}. Consider the following
decision problem:\index{\textsc{Shortest-Reset-Word}}

\smallskip

\hangindent=\parindent \noindent \textsc{Shortest-Reset-Word:}
\emph{Given a \san\ $\mathcal{A}$ and a positive integer $\ell$,
is it true that the minimum length of a reset word for
$\mathcal{A}$ is equal to $\ell$?}

\smallskip

\noindent Assigning the instance $(\mathcal{A}(\psi),n+1)$ of
\textsc{Shortest-Reset-Word} to an arbitrary system $\psi$ of
clauses on $n$ variables, one sees that the answer to the instance
is ``Yes'' if and only if $\psi$ is not satisfiable. Thus, we have
a polynomial reduction from the negation of \textsc{SAT} to
\textsc{Shortest-Reset-Word} whence the latter problem is
\textsf{coNP}-hard. As a corollary, \textsc{Shortest-Reset-Word}
cannot belong to \textsf{NP} unless \textsf{NP}\,=\,\textsf{coNP}
which is commonly considered to be very unlikely. In other words,
even non-deterministic algorithms cannot decide the minimum length
of a reset word for a given \san\ in polynomial time.

The exact complexity of the problem \textsc{Shortest-Reset-Word}
has been recently determined by
Gawrychowski~\cite{Gawrychowski:2008} and, independently, by
Olschewski and Ummels~\cite{Olschewski&Ummels:2010}. It turns out
that the appropriate complexity class is \textsf{DP}
(\textsf{Difference Polynomial-Time}) introduced by Papadimitriou
and Yannakakis~\cite{Papadimitriou&Yannakakis:1984}; this class
consists of languages of the form $L_1\cap L_2$ where $L_1$ is a
language from \textsf{NP} and a $L_2$ is a language in
\textsf{coNP}. A ``standard'' \textsf{DP}-complete problem is
\textsc{SAT-UNSAT} whose instance is a pair of clause systems
$\psi,\chi$, say, and whose question is whether $\psi$ is
satisfiable and $\chi$ is unsatisfiable.

\begin{proposition}
\label{KV:prop:complexity2} The problem
\textsc{Shortest-Reset-Word} is \textsf{DP}-complete.
\end{proposition}

Proposition~\ref{KV:prop:complexity2} follows from mutual
reductions between \textsc{Shortest-Reset-Word} and
\textsc{SAT-UNSAT} obtained
in~\cite{Gawrychowski:2008,Olschewski&Ummels:2010}.

The complexity class $\mathsf{P}^\mathsf{NP[log]}$ is defined as
the class of all problems that can be solved by a deterministic
polynomial-time Turing machine that has an access to an oracle for
an \textsf{NP}-complete problem, with the number of queries being
logarithmic in the size of the input. The class \textsf{DP} is
contained in $\mathsf{P}^\mathsf{NP[log]}$ (if fact, for every
problem in \textsf{DP} two oracle queries suffice) and the
inclusion is believed to be strict. Olschewski and
Ummels~\cite{Olschewski&Ummels:2010} have shown that the problem
of computing the minimum length of \sws\ (as opposed to deciding
whether it is equal to a given integer) is complete for the
functional analogue $\mathsf{FP}^\mathsf{NP[log]}$ of the class
$\mathsf{P}^\mathsf{NP[log]}$ (see \cite{Selman:1994} for a
discussion of functional complexity classes). Hence, this problem
appears to be even harder than deciding the minimum length of
\sws. Recently Berlinkov~\cite{Berlinkov:2010} has shown (assuming
\textsf{P}\,$\ne$\,\textsf{NP}) that no polynomial algorithm can
approximate the minimum length of \sws\ for a given \san\ within a
constant factor.

The problem of finding a \sw\ of minimum length (as opposed to
computing only the length without writing down the word itself)
may be even more difficult. From the quoted result
of~\cite{Olschewski&Ummels:2010} it follows that the problem is
$\mathsf{FP}^\mathsf{NP[log]}$-hard but its exact complexity is
not known yet.

We mention that Pixley, Jeong and
Hachtel~\cite{Pixley&Jeong&Hachtel:1992} suggested an heuristic
polynomial algorithm for finding short \sws\ in \sa\ that was
reported to perform rather satisfactory on a number of benchmarks
from~\cite{Yang:1991}; further polynomial algorithms yielding
short (though not necessarily shortest) \sws\ have been
implemented by Trahtman~\cite{Trahtman:2006} and
Roman~\cite{Roman:2009}. Some algorithms for finding \sws\ will be
also discussed in the next section.

\section{The \v{C}ern\'{y} conjecture}

A very natural question to ask is the following: \emph{given a
positive integer $n$, how long can be \sws\ for \sa\ with $n$
states?} \v{C}ern\'{y}~\cite{Cerny:1964} found a lower bound by
constructing, for each $n>1$, a \san\
$\mathcal{C}_n$\index{automaton!\v{C}ern\'{y}} with $n$ states and
2 input letters whose shortest \sw\ has length $(n-1)^2$. We
assume that the state set of $\mathcal{C}_n$ is
$Q=\{0,1,2,\dots,n-1\}$ and the input letters are $a$ and $b$,
subject to the following action on $Q$:
\begin{displaymath}
i\cdot a=\begin{cases}
i &\text{if } i>0,\\
1 &\text{if } i=0;
\end{cases}\quad
i\cdot b=i+1\!\!\pmod{n}.
\end{displaymath}
Our first example of \san\ (see Figure\,\ref{KV:fig:C4}) is, in
fact, $\mathcal{C}_4$. A generic automaton $\mathcal{C}_n$ is
shown in Figure\,\ref{KV:fig:cerny-n} on the left.

\begin{figure}[ht]
\begin{center}
\unitlength .45mm
\begin{picture}(72,76)(25,-86)
\gasset{Nw=16,Nh=16,Nmr=8,loopdiam=12} \node(n0)(36.0,-16.0){1}
\node(n1)(4.0,-40.0){$0$} \node(n2)(68.0,-40.0){2}
\node(n3)(16.0,-72.0){$n{-}1$} \node(n4)(56.0,-72.0){3}
\drawedge[ELdist=2.0](n1,n0){$a,b$}
\drawedge[ELdist=1.5](n2,n4){$b$}
\drawedge[ELdist=1.7](n0,n2){$b$}
\drawedge[ELdist=1.7](n3,n1){$b$}
\drawloop[ELdist=1.5,loopangle=30](n2){$a$}
\drawloop[ELdist=2.4,loopangle=-30](n4){$a$}
\drawloop[ELdist=1.5,loopangle=-90](n0){$a$}
\drawloop[ELdist=1.5,loopangle=210](n3){$a$} \put(31,-73){$\dots$}
\end{picture}
\begin{picture}(72,76)(-25,-86)
\gasset{Nw=16,Nh=16,Nmr=8} \node(n0)(36.0,-16.0){1}
\node(n1)(4.0,-40.0){$0$} \node(n2)(68.0,-40.0){2}
\node(n3)(16.0,-72.0){$n{-}1$} \node(n4)(56.0,-72.0){3}
\drawedge[ELdist=2.0](n1,n0){$b$}
\drawedge[ELdist=1.5](n2,n4){$b,c$}
\drawedge[ELdist=1.7](n0,n2){$b,c$}
\drawedge[ELdist=1.7](n3,n1){$b,c$}
\drawedge[ELdist=2.0](n1,n2){$c$} \put(31,-73){$\dots$}
\end{picture}
\end{center}
\caption{The DFA $\mathcal{C}_n$ and the DFA $\mathcal{W}_n$
induced by the actions of $b$ and $c=ab$}\label{KV:fig:cerny-n}
\end{figure}

The series $\mathcal{C}_n$ was rediscovered many times (see, e.g.,
\cite{Laemmel&Rudner:1969,Fischler&Tannenbaum:1970,Eppstein:1990}).
It is easy to see that the word $(ab^{n-1})^{n-2}a$ of length
$n(n-2)+1=(n-1)^2$ is a reset word for $\mathcal{C}_n$. There are
several nice proofs for \v{C}ern\'{y}'s
result~\cite[Lemma~1]{Cerny:1964} that $\mathcal{C}_n$ has no
shorter \sws. Here we present a recent proof
from~\cite{Ananichev&Gusev&Volkov:2010}; it is based on a
transparent idea and reveals an interesting connection between
\v{C}ern\'{y}'s automata $\mathcal{C}_n$ and an extremal series of
digraphs discovered in Wielandt's classic
paper~\cite{Wielandt:1950} (see Section~\ref{KV:sec:rcp}).

Let $w$ be a \sw\ of minimum length for $\mathcal{C}_n$. Since the
letter $b$ acts on $Q$ as a cyclic permutation, the word $w$
cannot end with $b$. (Otherwise removing the last letter gives a
shorter \sw.) Thus, we can write $w$ as $w = w'a$ for some
$w'\in\{a,b\}^*$ such that the image of $Q$ under the action of
$w'$ is precisely the set $\{0,1\}$.

Since the letter $a$ fixes each state in its image
$\{1,2,\dots,n-1\}$, every occurrence of $a$ in $w$ except the
last one is followed by an occurrence of $b$. (Otherwise $a^2$
occurs in $w$ as a factor and reducing this factor to just $a$
results in a shorter \sw.) Therefore, if we let $c=ab$, then the
word $w'$ can be rewritten into a word $v$ over the alphabet
$\{b,c\}$. The actions of $b$ and $c$ induce a new DFA on the
state set $Q$; we denote this induced DFA (shown in
Figure\,\ref{KV:fig:cerny-n} on the right) by $\mathcal{W}_n$.
Since $w'$ and $v$ act on $Q$ in the same way, the word $vc$ is a
\sw\ for $\mathcal{W}_n$ and brings the automaton to the state~2.

If $u\in\{b,c\}^*$, the word $uvc$ also is a \sw\ for
$\mathcal{W}_n$ and it also brings the automaton to~2. Hence, for
every $\ell\ge|vc|$, there is a path of length $\ell$ in
$\mathcal{W}_n$ from any given state $i$ to~2. In particular,
setting $i=2$, we conclude that for every $\ell\ge|w|$ there is a
cycle of length $\ell$ in $\mathcal{W}_n$. The underlying digraph
of $\mathcal{W}_n$ has simple cycles only of two lengths: $n$ and
$n-1$. Each cycle of $\mathcal{W}_n$ must consist of simple cycles
of these two lengths whence each number $\ell\ge|w|$ must be
expressible as a non-negative integer combination of $n$ and
$n-1$. Here we invoke the following well-known and elementary
result from arithmetics:

\begin{lemma}[{\mdseries\cite[Theorem 2.1.1]{RamirezAlfonsin:2005}}]
\label{KV:lemma:sylvester} If $k_1,k_2$ are relatively prime
positive integers, then $k_1k_2-k_1-k_2$ is the largest integer
that is not expressible as a non-negative integer combination of
$k_1$ and $k_2$.
\end{lemma}

Lemma~\ref{KV:lemma:sylvester} implies that
$|vc|>n(n-1)-n-(n-1)=n^2-3n+1$. Suppose that $|vc|=n^2-3n+2$. Then
there should be a path of this length from the state~1 to the
state~2. Every outgoing edge of~1 leads to~2, and thus, in the
path it must be followed by a cycle of length $n^2-3n+1$. No cycle
of such length may exist by Lemma~\ref{KV:lemma:sylvester}. Hence
$|vc|\ge n^2-3n+3$.

Since the action of $b$ on any set $S$ of states cannot change the
cardinality of $S$ and the action of $c$ can decrease the
cardinality by~1 at most, the word $vc$ must contain at least
$n-1$ occurrences of $c$. Hence the length of $v$ over $\{b,c\}$
is at least $n^2-3n+2$ and $v$ contain at least $n-2$ occurrences
of $c$. Since each occurrence of $c$ in $v$ corresponds to an
occurrence of the factor $ab$ in $w'$, we conclude that the length
of $w'$ over $\{a,b\}$ is at least $n^2-3n+2+n-2=n^2-2n$. Thus,
$|w|=|w'a|\ge n^2-2n+1=(n-1)^2$.


\section{The road coloring problem}
\label{KV:sec:rcp}

\section{Generalizations}

\bibliographystyle{abbrv}
\addcontentsline{toc}{section}{References}
\begin{footnotesize}
  \bibliography{abbrevs,SA}
\end{footnotesize}


\addcontentsline{toc}{section}{Index}
\markright{\indexname}\markboth{\indexname}{\indexname}
\printindex

\end{document}
